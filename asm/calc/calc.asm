; RPN Calculator
;--------------------------
; STACK 
; SIZE: 3
; LOCATION: (BASE) x3FFF to (MAX) x3FFB
; xC001 = -x3FFF
; xC005 = -x3FFB
;-------------------------
;  X = EXIT, D = DISPLAY TOS
;  C = CLEAR STACK
;  ENTER = PUSH INTEGER
;  OPS: +, *, - (NEGATE)
;--------------------------

; MAIN ALGORITHM
;----------------------
.ORIG x3000

LD R6, STACKBASE  ; INIT STACK x3FFF
ADD R6, R6, #-1    ; R6 IS STACK POINTER 
LEA R0, PROMPTMSG
PUTS
GETC
OUT

; CHECK COMMAND ENTERED
TEST
LD R1, NEGX	; TEST X
ADD R1, R1, R0
BRz EXIT

LD R1, NEGC	; TEST C
ADD R1, R1, R0
BRz OPCLEAR

LD R1, NEGPLUS	; TEST +
ADD R1, R1, R0
BRz OPADD

LD R1, NEGMULT	; TEST *
ADD R1, R1, R0
BRz OPMULT

LD R1, NEGMINUS ; TEST -
ADD R1, R1, R0
BRz OPNEG

LD R1, NEGD	; TEST D
ADD R1, R1, R0
BRz OPDISPLAY

; MUST BE ENTERING AN INTEGER
BR PUSHVALUE

NEWCOMMAND
LEA R0, PROMPTMSG
PUTS
GETC
OUT
BR TEST

EXIT
LEA R0, BYEMSG
PUTS
HALT	; TRAP x25

; DATA
ASCIIBUFF .BLKW #4 	; POINTS TO STRING BEING GENERATED?
STACKBASE .FILL x3FFF   ; ADDRESS OF STACK BASE x3FFF
NEGX	  .FILL xFFA8
NEGC	  .FILL xFFBD
NEGPLUS   .FILL xFFD5
NEGMINUS  .FILL xFFD3
NEGMULT   .FILL xFFD6
NEGD	  .FILL xFFBC
PROMPTMSG .STRINGZ "\nENTER A COMMAND: "
BYEMSG .STRINGZ "\nEND OF CALC\n"
;----------------------

;====================================================

;----------------------------------------------
; PUSHVALUE: 
;  TAKE SEQUENCE OF ASCII FROM USER
;  CONVERT TO BINARY BY CALL ASCIITOBINARY
;  PUSH ON STACK
;----------------------------------------------
PUSHVALUE
LEA R1, ASCIIBUFF ; R1 POINTS TO STRING BEING GENERATED
LD R2, MAXDIGITS

VALUELOOP
ADD R3, R0, xFFF6 ; TEST CARRIGE RETURN
BRz GOODINPUT
ADD R2, R2, #0
BRz TOOLARGEINPUT
ADD R2, R2, #-1   ; STILL ROOM FOR MORE DIGITS
STR R0, R1, #0    ; STORE LAST CHAR READ
ADD R1, R1, #1
GETC
OUT 
BR VALUELOOP

GOODINPUT
LEA R2, ASCIIBUFF
NOT R2, R2
ADD R2, R2, #1
ADD R1, R1, R2   ; R1 NOW HAS NUM OF CHARS
JSR ASCIITOBINARY
JSR PUSH
BR NEWCOMMAND

TOOLARGEINPUT
GETC
OUT
ADD R3, R0, xFFF6
BRnp TOOLARGEINPUT
LEA R0, TOOMANY
PUTS
BR NEWCOMMAND

;DATA
MAXDIGITS .FILL x0003
TOOMANY .STRINGZ "\nTOO MANY DIGITS"
;----------------------------------------------


;----------------------------------------------
; ASCIITOBINARY: SUBROUTINE
;  TAKES AN ASCII STRING OF 3 DECIMAL DIGITS
;  CONVERTS TO BINARY
;  R0 IS USED TO COLLECT RESULT
;  R1 KEEPS TRAK HOW MANY DIGITS LEFT TO PROCESS
; ASCIIBUFF 
;----------------------------------------------
ASCIITOBINARY
AND R0, R0, #0	; R0 USED FOR RESULT
ADD R1, R1, #0  ; TEST NUM DIGITS
BRz DONEATOB	; NO DIGITS

LD R3, NEGASCIIOFFSET
LEA R2, ASCIIBUFF
ADD R2, R2, R1
ADD R2, R2, #-1 ; R2 NOW POINTS TO 1'S DIGIT

LDR R4, R2, #0  ; R4 ONES DIGIT
ADD R4, R4, R3	; STRIP ASCII
ADD R0, R0, R4	; ADD ONES CONTRIBUTION

ADD R1, R1, #-1
BRz DONEATOB	; ORIGINAL NUMBER HAD ONLY 1 DIGIT
ADD R2, R2, #-1 ; R2 NOW POINTS TO TENS DIGIT

LDR R4, R2, #0  ; R4 TENS DIGIT
ADD R4, R4, R3  ; STRIP ASCII
LEA R5, LOOKUP10 ; BASE 10 VALUES
ADD R5, R5, R4  ; R5 POINTS TO THE RIGHT TENS VALUE
LDR R4, R5, #0
ADD R0, R0, R4  ; ADD TENS CONTRIBUTION

ADD R1, R1, #-1
BRz DONEATOB	; ORIGINAL NUKBER HAD 2 DIGITS
ADD R2, R2, #-1 ; NOW R2 POINTS TO HUNDREDS DIGIT

LDR R4, R2, #0  ; R4 HUNDREDS DIGIT
ADD R4, R4, R3  ; STRIP ASCII
LEA R5, LOOKUP100 ; HUNDREDS BASE
ADD R5, R5, R4  ; R5 POINTS TO HUNDERDS VALUE
LDR R4, R5, #0
ADD R0, R0, R4  ; ADD HUNDREDS CONTRIBUTION

DONEATOB
RET

; DATA
NEGASCIIOFFSET .FILL xFFD0
LOOKUP10 .FILL #0
	 .FILL #10
	 .FILL #20
	 .FILL #30
	 .FILL #40
	 .FILL #50
	 .FILL #60
	 .FILL #70
	 .FILL #80
	 .FILL #90

LOOKUP100 .FILL #100
	  .FILL #200
	  .FILL #300
	  .FILL #400
	  .FILL #500
	  .FILL #600
	  .FILL #700
	  .FILL #800
	  .FILL #900
;----------------------------------------------

;----------------------------------------------
; BINARYTOASCII: SUBROUTINE
;  CONVERT AN INTEGER BETWEEN -999 AND 999 TO ASCII
;  STRING CONTAINS SIGN FOLLOWED BY 3 DIGITS
;  R0 HAS INITIAL VAL TO CONVERT
;----------------------------------------------
BINARYTOASCII
LEA R1, ASCIIBUFF	; R1 POINTS TO STRING BEING GENERATED
ADD R0, R0, #0		; R0 CONTAINS BINARY VALUE
BRn NEGSIGN
LD R2, ASCIIPLUS	; STORE + SIGN
STR R2, R1, #0
BR BEGIN100

NEGSIGN
LD R2, ASCIIMINUS	; STORE - SIGN
STR R2, R1, #0
NOT R0, R0
ADD R0, R0, #1		; CONVERT TO ABSOLUTE VALUE

BEGIN100
LD R2, ASCIIOFFSET	; PREPARE FOR HUNDREDS DIGIT
LD R3, NEG100

LOOP100
  ADD R0, R0, R3
  BRn END100
  ADD R2, R2, #1
  BR LOOP100  

END100
STR R2, R1, #1		; STORE ASCII CODE FOR HUNDRED DIGIT
LD R3, POS100
ADD R0, R0, R3		; CORRECT FOR 1 TOO MANY SUBTRACTS

BEGIN10
LD R2, ASCIIOFFSET	; PREPARE FOR TENS
LD R3, NEG10		; DETERMINE TENS DIGIT

LOOP10
  ADD R0, R0, R3
  BRn END10
  ADD R2, R2, #1
  BR LOOP10

END10
STR R2, R1, #2		; STORE ASCII CODE FOR TENS DIGIT
ADD R0, R0, #10		; CORRECT R0 FOR 1 TOO MANY SUBTRACTS

BEGIN1
LD R2, ASCIIOFFSET	; PREPARE FOR ONES DIGIT
ADD R2, R2, R0
STR R2, R1, #3
RET

;DATA
ASCIIPLUS .FILL x002B
ASCIIMINUS .FILL x002D
ASCIIOFFSET .FILL x0030
NEG100 .FILL #-100
POS100 .FILL #100
NEG10 .FILL #-10
;----------------------------------------------

;----------------------------------------------
; CLEAR
;  RESET STACK POINTER (R6)
;----------------------------------------------
OPCLEAR
LD R6, STACKBASE
ADD R6, R6, #-1
BR NEWCOMMAND
;----------------------------------------------

;----------------------------------------------
; DISPLAY
;  CALLS BINARY2ASCII ON TOP OF STACK
;  CALLS PUTS ON ASCII VALUE STRING
;----------------------------------------------
OPDISPLAY
JSR POP 	; R0 GET VAL TO DISPLAY
ADD R5, R5, #0  ; CHECK IF SUCCESS POP
BRp NEWCOMMAND  ; POP FAIL NO VAL ON STACK
JSR BINARYTOASCII
LD R0, NEWLINECHAR
OUT
LEA R0, ASCIIBUFF
PUTS
ADD R6, R6, #-1 ; PUSH DISPLAYED NUM ON STACK
BR NEWCOMMAND
NEWLINECHAR .FILL x0A
;----------------------------------------------

;---------------------------------------------
; NEG:
;  POP TOP OF STACK MAKE NEGATIVE AND PUSH BACK ON
;---------------------------------------------
OPNEG
JSR POP 	; GET OPERAND
ADD R5, R5, #0  ; TEST IF SUCCESSFUL POP
BRp N_EXIT	; BRANCH IF FAILURE
NOT R0, R0	; 
ADD R0, R0, #1  ; FORM NEGATIVE OF SOURCE
JSR PUSH
N_EXIT
 BR NEWCOMMAND
;---------------------------------------------

;---------------------------------------------
; ADD:
;  POP 2 ELEMENTS FROM STACK
;  ADD THEM PUSH BACK ON STACK
;  R6 IS STACK POINTER
;---------------------------------------------
OPADD
JSR POP 	; GET FIRST SOURCE OPERAND
ADD R5, R5, #0  ; TEST IF POP SUCCESS
BRp A_EXIT	; BRANCH IF NOT SUCESSFUL
ADD R1, R0, #0  ; MAKE ROOM FOR SECOND OPERAND
JSR POP		; GET SECOND OPERAND
ADD R5, R5, #0  ; TEST IF POP SUCCESS
BRp A_RESTORE1	; IF FAIL RESTORE OPERAND 1
ADD R0, R0, R1  ; THE ADD
JSR RANGECHECK  ; CHECK SIZE OF RESULT
BRp A_RESTORE2	; OUT OF RANGE RESTORE BOTH
JSR PUSH	; PUSH SUM ONTO STACK
BR NEWCOMMAND	; NEXT TASK

A_RESTORE1
 ADD R6, R6, #-1 ; DECREMENT STACK POINTER
A_RESTORE2
 ADD R6, R6, #-1 ; DECREMENT STACK POINTER
A_EXIT 
 BR NEWCOMMAND
;----------------------------------------------

;---------------------------------------------
; MUL:
;  POP 2 ELEMENTS OFF STACK
;  MULTIPLY THEM PUSH BACK ON STACK
;  R6 IS STACK POINTER
;---------------------------------------------
OPMULT
AND R3, R3, #0  ; R3 HOLDS SIGN OF MULTIPLIER
JSR POP
ADD R5, R5, #0  ; TEST SUCCESS POP
BRp M_EXIT	; FAILURE
ADD R1, R0, #0  ; MAKE ROOM FOR NEXT POP
JSR POP
ADD R5, R5, #0  ; TEST SUCCESS POP
BRp M_RESTORE1  ; FAILURE, RESTORE FORST POP
ADD R2, R0, #0  ; MOVE MULTIPLIER, TEST SIGN
BRzp POSMULTIPLIER
ADD R3, R3, #1  ; SET FLAG MULTIPLIER IS NEGATIVE
NOT R2, R2
ADD R2, R2, #1  ; R2 CONTAINS -(MULTIPLIER)
POSMULTIPLIER
AND R0, R0, #0  ; CLEAR PRODUCT REGISTER
ADD R2, R2, #0
BRz PUSHMULT

MULTLOOP
ADD R0, R0, R1  ; ACTUAL MULTIPLY
ADD R2, R2, #-1 ; ITERATION CONTROL
BRp MULTLOOP

JSR RANGECHECK  ; DONE MULT, CHECK IF IN RANGE
ADD R5, R5, #0
BRp M_RESTORE2

ADD R3, R3, #0  ; TEST FOR NEGATIVE MULTIPLIER
BRz PUSHMULT
NOT R0, R0
ADD R0, R0, #1  ; ADJUST FOR SIGN OF RESULT

PUSHMULT
JSR PUSH	; PUSH PRODUCT ONTO STACK
BR NEWCOMMAND

M_RESTORE1
 ADD R6, R6, #-1
M_RESTORE2
 ADD R6, R6, #-1
M_EXIT
 BR NEWCOMMAND
;---------------------------------------------

; SUBROUTINES:  (USING RET, INSTEAD OF BRnzp NEWCOMMAND)
;=================================================

;---------------------------------------------
; RANGECHECK: SUBROUTINE
;  CHECK IF THE  MAGNITUDE OF A VALUE IN R0 IS 
;  BETWEEN: -999 AND +999
;---------------------------------------------
RANGECHECK
LD R5, NEG999
ADD R4, R5, R0  ; R0 HAS RESULT TO CHECK
BRp BADRANGE
LD R5, POS999
ADD R4, R5, R0
BRn BADRANGE
AND R5, R5, #0  ; SUCCESS
RET

BADRANGE
ST R7, RC_SAVER7 ; NEEDED BY TRAP/RET
LEA R0, RANGE_ERR
PUTS		; TRAP x22
LD R7, RC_SAVER7
AND R5, R5, #0
ADD R5, R5, #1  ; FAILURE
RET

; DATA
NEG999 .FILL #-999
POS999 .FILL #999
RC_SAVER7 .BLKW #1
RANGE_ERR .STRINGZ "\nERROR: NUMBER OUT OF RANGE"
;---------------------------------------------

;----------------------------------------------
; POP: SUBROUTINE
;  POP FROM STACK, PUT IN R0, RETURN TO CALLING PROGRAM
;  R5 IS FLAG; SUCCESS = 0 ;  FAIL = 1
;----------------------------------------------
POP
LD R0, POPBASE ; STACK BASE x3FFF
NOT R0, R0
ADD R0, R0, #2 ; R0 = -(ADDR.STACKBASE - 1)  -x4000
ADD R0, R0, R6 ; R6 = STACK POINTER
BRz UNDERFLOW
LDR R0, R6, #0 ; POP
ADD R6, R6, #1 ; ADJUST STACK POINTER
AND R5, R5, #0 ; SUCCESS
RET
UNDERFLOW
LEA R0, UFMSG  ; PRINT ERROR MESSAGE
PUTS
LD R7, POP_SAVER7
AND R5, R5, #0
ADD R5, R5, #1 ; FAIL
RET
POP_SAVER7 .BLKW #1
POPBASE .FILL x3FFF ; x3FFF STACK BASE
UFMSG .STRINGZ "\nERROR: TOO FEW VALS ON STACK"
;----------------------------------------------

;----------------------------------------------
; PUSH: SUBROUTINE
;  VAL IN R0 ONTO STACK
;  R5 IS FLAG; SUCCESS = 0, FAIL =1
;----------------------------------------------
PUSH
ST R1, PUSH_SAVER1
LD R1, STACKMAX
NOT R1, R1
ADD R1, R1, #1  ; -(ADDR.STACKMAX)  -x3FFB
ADD R1, R1, R6  ; R6 = STACK POINTER
BRz OVERFLOW
ADD R6, R6, #-1 ; ADJUST STACK POINTER FOR PUSH
STR R0, R6, #0  ; ACTUAL PUSH
BR SUCCESSEXIT

OVERFLOW
ST R7, PUSH_SAVER7
LEA R0, OFMSG
PUTS
LD R7, PUSH_SAVER7
LD R1, PUSH_SAVER1
AND R5, R5, #0
ADD R5, R5, #1	; FAIL
RET

SUCCESSEXIT
LD R1, PUSH_SAVER1
AND R5, R5, #0
RET

;DATA
PUSH_SAVER1 .BLKW #1
PUSH_SAVER7 .BLKW #1
STACKMAX .FILL x3FFB ;x3FFB  STACK MAX
OFMSG .STRINGZ "\nERROR: STACK FULL"
;----------------------------------------------

.END