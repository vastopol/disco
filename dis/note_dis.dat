disasm notes
--------------------

scripts:

disco = suite
bang = test harness
lc3_conv.py = format converter
lc3_dis.py = disassembler
lc3_asm.py = assembler

if possible to compile lc3tools && lcc then those executables should be called to do the bin -> obj

----------------------------------------

test files:

* all.bin    = all binary examples from ch5 & ch6 in one file
* custom.bin = handmade binary to test cases not in the examples

----------------------------------------

illegal instruction op = 1101
JSR and JSRR both have op = 0100
JMP and RET both have op = 1100, RET is actually JMP R7

Trap x20 GETC
Trap x21 OUT
Trap x22 PUTS
Trap x23 IN
Trap X24 PUTSP
Trap x25 HALT

LD, LDI, LEA, ST, STI have same decoding scheme if don't care about src/dst specifics related to 1st register
shouldn't matter since there is only 1 register and the rest is pcoffset9

JSR/JSRR needs special logic inside to determine which one based on a flag bit

AND, ADD have the same decoding scheme, but also needs special logic inside to determine which one based on a flag bit

also need to be careful since i think the binary isn't 1 to 1 with the assembly,
the order of operands for the syntax can be different than the order in the bitstring.
should only apply to some of the operations that have multiple operands

the whole newline vs carriage return is relevant. must pick only one.
diff of file with LF vs CRLF will be off even if every other character is the same.
this should use LF as the choice.

might need to trim the hex outputs
since lc3 expects x25 not 0x25
change  str(hex(int(offset,2))) -> format(int(offset,2)"X")
so it wont prepend a 0 before x

----------------------------------------

possible things to do:

dis.py  should output the markers
.orig xHEX
.end

typical lc3 assembly will start at x3000

should lable trap calls with coments
TRAP x25 ; HALT

change the random binary pc offsets & immediates to hex

should look for returns and comment them
JMP R7 ; RET

----------------------------------------

weird error

the big if/elif/else branch in lc3_dis.py has strange behavior
specifically the part where the NOT code is disassembled
if does not work properly when an elif is used, has to be a separate if
when elif the code does some decoding i don't understand and shouldn't be possible...
and it wont execute some commands...

i dont understand and cut out the code, deal with it later...


# this looks wrong too ???
elif op_str == "LDR" or "STR":
    reg1 = body[:3]
    reg2 = body[3:6]
    offset = body[6:]
    body_str += " R"
    body_str += str(int(reg1,2))
    body_str += ", R"
    body_str += str(int(reg2,2))
    body_str += ", x"
    body_str += format(int(offset,2),"X")

 # dont know why but when elif does not work properly
 # it will mess up execution flow for the rest of the branch
 # when elif will decode NOT incorrect, looks exactly like LDR/STR
 # can even put in sys.exit(1) and it wont execute.
 # when is if then body_str gets filled and decoded auto R#, R#, x#
 # i dont know how that happens...
 # then when try to add the R + str + R + str if comes out bad R#, R#, x#R#, R#
 # so have to set body_str = "" again even though it is set to "" when opcode is fetched at top
 # looks like it is saved each call...
 # WTF!!!
if op_str == "NOT": # has to be a separate branch
    reg1 = body[:3]
    reg2 = body[3:6]
    #print(body_str)
    body_str = "" # have to clear it here
    #print(body_str)
    body_str += " R"
    body_str += str(int(reg1,2))
    body_str += ", R"
    body_str += str(int(reg2,2))
    #print(body_str)
    #sys.exit(1)
if op_str == "ADD" or "AND":
    reg1 = body[:3]
    reg2 = body[3:6]
    flag = body[6]
    rest = body[7:]
    body_str = ""
    print(reg1,reg2,flag,rest,body_str)
    # sys.exit(0)
    body_str += " R"
    body_str += str(int(reg1,2))
    body_str += ", R"
    body_str += str(int(reg2,2))
    body_str += ", "
    if flag == "1":
        body_str += "x"
        rest
        print("rest: x",rest)
        body_str += format(int(body,2),"X")
    else:
        body_str += "R"
        print("rest: R",rest, len(rest))
        body_str += str(int(rest,2))
    print(body_str)
elif op_str == "JSR" :
    pass